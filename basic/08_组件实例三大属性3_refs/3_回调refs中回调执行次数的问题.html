<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>3_回调refs中回调执行次数的问题</title>
  <style>

  </style>
</head>
<body>
  <div id="test"></div>
  <!-- 引入 react_development.js   react-dom.development.js  babel.min.js -->
  <script src="../js/react.development.js"></script>
  <script src="../js/react-dom.development.js"></script>
  <script src="../js/babel.min.js"></script>
  <script type="text/babel">
    // 1. 创建类式组件
    class Demo extends React.Component {
      state = { isOpen: true }

      render() {
        const { isOpen } = this.state;
        return (
          <div>
            <h2>当前状态是{ isOpen ? '打开' : '关闭' }</h2>
            <button onClick={ this.changeOpenState }>改变当前状态</button>
            <br />
            {/*<input ref={(node) => { this.input1 = node }} type="text" />*/}
            <input ref={ this.saveInput1 } type="text" />
            <button onClick={ this.showTip }>提示</button>
          </div>
        )
      }
      changeOpenState = () => {
        // 内联函数的ref写法，每次触发render渲染，都会触发ref中回调函数的执行，并且是两次，node参数第一次是null第二次是真实dom
        // 因为每次渲染时会创建一个新的函数实例，所以React清空旧的ref并且设置新的ref，这样就会触发两次回调函数（第一次传null清空，第二次传入真实dom重新赋值）
        // 把回调函数定义成class的绑定函数的方式可以避免这个问题，不过其实无关紧要
        this.setState({ isOpen: !this.state.isOpen }) 
      }
      saveInput1 = (node) => {
        // class的绑定函数的方式
        this.input1 = node;
      }
      showTip = () => {
        const {input1} = this;
        alert(input1.value);
      }
    }

    // 2. 渲染组件
    ReactDOM.render(<Demo />, document.getElementById('test'));

  </script>
</body>
</html>